
/*******************************************************************************
*
* File dfl_parms.c
*
* Copyright (C) 2009, 2010, 2011, 2013 Martin Luescher
*               2017, 2019 Agostino Patella
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* Deflation parameters
*
* The externally accessible functions are
*
*   dfl_parms_t set_dfl_parms(int *bs,int Ns)
*     Sets the parameters of the deflation subspaces. The parameters are
*
*       bs[4]          Sizes of the blocks in DFL_BLOCKS block grid.
*
*       Ns             Number of deflation modes per block (must be
*                      even and non-zero).
*
*     The return value is a structure that contains the above parameters.
*     Note that these parameters can only be set once.
*
*   dfl_parms_t dfl_parms(void)
*     Returns the parameters currently set for the deflation subspace.
*
*   dfl_pro_parms_t set_dfl_pro_parms(int nkv,int nmx,double res)
*     Sets the parameters used when applying the deflation projection in the
*     deflated solver program dfl_sap_gcr(). The parameters are
*
*       nkv            Maximal number of Krylov vectors to be used by the
*                      solver for the little Dirac equation before a restart.
*
*       nmx            Maximal total number of Krylov vectors generated by
*                      the solver for the little Dirac equation.
*
*       res            Required relative residue when solving the little
*                      Dirac equation.
*
*     The return value is a structure that contains the above parameters. 
*
*   dfl_pro_parms_t dfl_pro_parms(void)
*     Returns the parameters currently set for the deflation projectors in
*     the deflated solver program dfl_sap_gcr().
*
*   dfl_gen_parms_t set_dfl_gen_parms(int idfl,double kappa,double mu,
*                                     int qhat,double su3csw,double u1csw,
*                                     double cF,double cF_prime,
*                                     double th1,double th2,double th3,
*                                     int ninv,int nmr,int ncy)
*     Sets the parameters of the inverse iteration procedure that generates
*     the deflation subspaces. The parameters are
*
*       idfl           Index of the deflation subspace to be used.
*
*       kappa          Hopping parameter of the Dirac operator.
*
*       mu             Twisted mass parameter.
*
*       qhat           Electric charge.
*
*       su3csw,u1csw   Coefficients of the SU(3) and U(1) Sheikholeslami-Wohlert
*                      term respectively.
*
*       cF,cF_prime    Fermion action improvement coefficients at time 0
*                      and T, respectively.
*
*       th1,th2,th3    Angles specifying the phase-periodic boundary
*                      conditions for the quark fields in direction 1,2,3.       
*
*       ninv           Total number of inverse iteration steps (ninv>=4).
*
*       nmr            Number of block minimal residual iterations to be 
*                      used when the SAP smoother is applied.
*
*       ncy            Number of SAP cycles per inverse iteration.
*
*     The return value is a structure that contains the above parameters and
*     the bare mass m0 that corresponds to the hopping parameter kappa.
*
*   dfl_gen_parms_t dfl_gen_parms(int idfl)
*     Returns the parameters currently set for the generation of the deflation
*     subspace with index idfl.
*
*   dfl_upd_parms_t set_dfl_upd_parms(double dtau,int nsm)
*     Sets the parameters of the deflation subspace update scheme. The
*     parameters are
*
*       dtau           Molecular-dynamics time separation between 
*                      updates of the deflation subspace.
*
*       nsm            Number of deflated smoothing interations to be
*                      applied when the subspace is updated.
*
*     The return value is a structure that contains the above parameters.
*
*   dfl_upd_parms_t dfl_upd_parms(void)
*     Returns the parameters currently set for the deflation subspace
*     update scheme.
*
*   void print_dfl_parms(int ipr)
*     Prints the parameters of the deflation subspace, the projectors, the
*     subspace generation algorithm and the update scheme to stdout on MPI
*     process 0. The update scheme is omitted if ipr=0.
*
*   void write_dfl_parms(FILE *fdat)
*     Writes the parameters of the deflation subspace, the projectors, the
*     subspace generation algorithm and the update scheme to the file fdat
*     on MPI process 0.
*
*   void check_dfl_parms(FILE *fdat)
*     Compares the parameters of the deflation subspace, the projectors the
*     subspace generation algorithm and the update scheme with the values
*     stored on the file fdat on MPI process 0, assuming the latter were
*     written to the file by the program write_dfl_parms() (mismatches of
*     maximal solver iteration numbers are not considered to be an error).
*
*   void read_dfl_parms(int idfl)
*     On process 0, this program reads the following sections from the stdin,
*     as explained in more details in doc/parms.pdf.
*
*     If 'idfl<0' the program reads the following sections
*
*       [Deflation subspace]
*       bs        <int> <int> <int> <int>
*       Ns        <int>
*
*       [Deflation projection]
*       nkv       <int>
*       nmx       <int>
*       res       <double>
**       
*     If 'idfl=-2', then also the following section is read
*
*       [Deflation update scheme]
*       dtau      <double>
*       nsm       <int>

*     If 'idfl>=0' then 'idfl' is interpreted as the index of a deflation
*     subspace the following section is read
*       
*       [Deflation subspace generation idfl]
*       kappa     <double>
*       qhat      <int>
*       mu        <double>
*       su3csw    <double>
*       u1csw     <double>
*       cF        <double>
*       cF'       <double>
*       theta     <double> <double> <double>
*       ninv      <int>
*       nmr       <int>
*       ncy       <int>
*
*     Depending on the the active gauge group and on the boundary conditions,
*     some lines are not read and can be omitted in the input file. After
*     reading the stdin, the deflation parameters are set with 'set_dfl_parms',
*     'set_dfl_pro_parms', 'set_dfl_gen_parms', 'set_dfl_upd_parms'.
*
* Notes:
*
* To ensure the consistency of the data base, the parameters must be set
* simultaneously on all processes. The types dfl_parms_t, ... are defined
* in the file flags.h.
*
*******************************************************************************/

#define DFL_PARMS_C

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include "mpi.h"
#include "utils.h"
#include "flags.h"
#include "global.h"

#define DFLMAX 32

static dfl_parms_t dfl={{0,0,0,0},0};
static dfl_pro_parms_t dfl_pro={0,0,1.0};
static dfl_gen_parms_t dfl_gen[DFLMAX+1]={{DFL_OUTOFRANGE,0,0,0,0.0,0.0,
                        {0,DBL_MAX,0.0,0.0,{0.0,0.0},{0.0,0.0,0.0}}}};
static dfl_upd_parms_t dfl_upd={0,0.0};


static void init_dfl(void)
{
   static int init=0;
   int i;
   
   if (init==1) return;
   
   for (i=1;i<=DFLMAX;i++)
      dfl_gen[i]=dfl_gen[0];

   init=1;
}


static void check_block_size(int *bs)
{
   int n0,n1,n2,n3;
   
   error_root((bs[0]<4)||(bs[1]<4)||(bs[2]<4)||(bs[3]<4)||
              (bs[0]>L0)||(bs[1]>L1)||(bs[2]>L2)||(bs[3]>L3),1,
              "check_block_size [dfl_parms.c]",
              "Block sizes are out of range");

   error_root((bs[0]%2)||(bs[1]%2)||(bs[2]%2)||(bs[3]%2),1,
              "check_block_size [dfl_parms.c]",
              "Block sizes must be even");
   
   error_root((L0%bs[0])||(L1%bs[1])||(L2%bs[2])||(L3%bs[3]),1,
              "check_block_size [dfl_parms.c]",
              "Blocks do not divide the local lattice");

   n0=L0/bs[0];
   n1=L1/bs[1];
   n2=L2/bs[2];
   n3=L3/bs[3];

   error_root(((NPROC0*n0)%2)||((NPROC1*n1)%2)||
              ((NPROC2*n2)%2)||((NPROC3*n3)%2),1,
              "check_block_size [dfl_parms.c]",
              "There must be an even number of blocks in each direction");

   error_root((n0*n1*n2*n3)%2,1,
              "check_block_size [dfl_parms.c]",
              "The number of blocks in the local lattice must be even");
}


dfl_parms_t set_dfl_parms(int *bs,int Ns)
{
   check_global_int("set_dfl_parms",5,bs[0],bs[1],bs[2],bs[3],Ns);

   error_root((dfl.Ns>0)&&((bs[0]!=dfl.bs[0])||(bs[1]!=dfl.bs[1])||
                           (bs[2]!=dfl.bs[2])||(bs[3]!=dfl.bs[3])||
                           (Ns!=dfl.Ns)),1,
              "set_dfl_parms [dfl_parms.c]","bs[4] and Ns may be set only once");
   
   check_block_size(bs);
   error_root((Ns<2)||(Ns&0x1),1,"set_dfl_parms [dfl_parms.c]",
              "Improper value of Ns");
   
   init_dfl();

   dfl.bs[0]=bs[0];
   dfl.bs[1]=bs[1];
   dfl.bs[2]=bs[2];
   dfl.bs[3]=bs[3];
   dfl.Ns=Ns;
   
   return dfl;
}


dfl_parms_t dfl_parms(void)
{
   init_dfl();

   return dfl;
}


dfl_pro_parms_t set_dfl_pro_parms(int nkv,int nmx,double res)
{
   check_global_int("set_dfl_pro_parms",2,nkv,nmx);
   check_global_dble("set_dfl_pro_parms",1,res);

   error_root((nkv<1)||(nmx<1)||(res<=DBL_EPSILON),1,
              "set_dfl_pro_parms [dfl_parms.c]","Improper parameter values");
   
   init_dfl();
   
   dfl_pro.nkv=nkv;
   dfl_pro.nmx=nmx;
   dfl_pro.res=res;
   
   return dfl_pro;
}


dfl_pro_parms_t dfl_pro_parms(void)
{
   init_dfl();

   return dfl_pro;
}


dfl_gen_parms_t set_dfl_gen_parms(int idfl,double kappa,double mu,
                                  int qhat,double su3csw,double u1csw,
                                  double cF,double cF_prime,
                                  double th1,double th2,double th3,
                                  int ninv,int nmr,int ncy)
{
   int i;
   
   check_global_int("set_dfl_gen_parms",5,idfl,qhat,ninv,nmr,ncy);
   check_global_dble("set_dfl_gen_parms",9,kappa,mu,su3csw,u1csw,cF,cF_prime,
                                           th1,th2,th3);

   error_root((idfl<0)||(idfl>=DFLMAX),1,"set_dfl_gen_parms [dfl_parms.c]",
              "Parameter idfl is out of range");

   error_root((ninv<4)||(nmr<1)||(ncy<1)||(kappa<0.0),1,
              "set_dfl_gen_parms [dfl_parms.c]","Parameters are out of range");
   
   init_dfl();

   error_root(dfl_gen[idfl].status==DFL_DEF,1,
              "set_dfl_gen_parms [dfl_parms.c]","Parameters for generation of deflation subspace %d are already set",idfl);

   dfl_gen[idfl].status=DFL_DEF;

   dfl_gen[idfl].ninv=ninv;
   dfl_gen[idfl].nmr=nmr;
   dfl_gen[idfl].ncy=ncy;

   dfl_gen[idfl].kappa=kappa;
   dfl_gen[idfl].mu=mu;

   dfl_gen[idfl].dp.qhat=0;
   dfl_gen[idfl].dp.su3csw=0.0;
   dfl_gen[idfl].dp.u1csw=0.0;
   dfl_gen[idfl].dp.cF[0]=0.0;
   dfl_gen[idfl].dp.cF[1]=0.0;
   dfl_gen[idfl].dp.theta[0]=0.0;
   dfl_gen[idfl].dp.theta[1]=0.0;
   dfl_gen[idfl].dp.theta[2]=0.0;
   if ((gauge()&2)!=0)
   {
      dfl_gen[idfl].dp.qhat=qhat;
      dfl_gen[idfl].dp.u1csw=u1csw;
   }
   if ((gauge()&1)!=0)
      dfl_gen[idfl].dp.su3csw=su3csw;
   if ((bc_type()>=0)&&(bc_type()<3))
   {
      dfl_gen[idfl].dp.cF[0]=cF;
      if (bc_type()==0)
         dfl_gen[idfl].dp.cF[1]=cF;
      else if (bc_type()==1)
         dfl_gen[idfl].dp.cF[1]=cF;
      else if (bc_type()==2)
         dfl_gen[idfl].dp.cF[1]=cF_prime;
   }
   if (bc_cstar()==0)
   {
      dfl_gen[idfl].dp.theta[0]=th1;
      dfl_gen[idfl].dp.theta[1]=th2;
      dfl_gen[idfl].dp.theta[2]=th3;
   }

   if (kappa!=0.0)
      dfl_gen[idfl].dp.m0=1.0/(2.0*kappa)-4.0;
   else
      dfl_gen[idfl].dp.m0=DBL_MAX;
   
   for (i=0;i<idfl;i++)
   {
      if (dfl_gen[i].status==DFL_OUTOFRANGE)
         dfl_gen[i].status=DFL_UNDEF;
   }
   
   return dfl_gen[idfl];
}


dfl_gen_parms_t dfl_gen_parms(int idfl)
{
   init_dfl();

   if ((idfl>=0)&&(idfl<DFLMAX))
      return dfl_gen[idfl];
   else
   {
      error_loc(1,1,"dfl_gen_parms [dfl_parms.c]",
                "Deflation index is out of range");
      return dfl_gen[DFLMAX];
   }
}


dfl_upd_parms_t set_dfl_upd_parms(double dtau,int nsm)
{
   check_global_int("set_dfl_upd_parms",1,nsm);
   check_global_dble("set_dfl_upd_parms",1,dtau);

   error_root((dtau<0.0)||(nsm<0),1,
              "set_dfl_upd_parms [dfl_parms.c]","Improper parameter values");
   
   init_dfl();

   dfl_upd.dtau=dtau;
   dfl_upd.nsm=nsm;
   
   return dfl_upd;
}


dfl_upd_parms_t dfl_upd_parms(void)
{
   init_dfl();

   return dfl_upd;
}


void print_dfl_parms(int ipr)
{
   int my_rank,n,idfl;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
   
   if (my_rank==0)
   {
      printf("Deflation subspace:\n");
      printf("bs = %d %d %d %d\n",dfl.bs[0],dfl.bs[1],dfl.bs[2],dfl.bs[3]);
      printf("Ns = %d\n\n",dfl.Ns);

      printf("Deflation projection:\n");
      printf("nkv = %d\n",dfl_pro.nkv);
      printf("nmx = %d\n",dfl_pro.nmx);
      printf("res = %.1e\n\n",dfl_pro.res);

      for (idfl=0;idfl<DFLMAX;idfl++)
      {
         if (dfl_gen[idfl].status==DFL_DEF)
         {
            printf("Deflation subspace generation %d:\n",idfl);
            n=fdigits(dfl_gen[idfl].kappa);
            printf("kappa = %.*f\n",IMAX(n,1),dfl_gen[idfl].kappa);
            n=fdigits(dfl_gen[idfl].mu);
            printf("mu = %.*f\n",IMAX(n,1),dfl_gen[idfl].mu);
            if ((gauge()&2)!=0)
            {
               printf("qhat = %d\n",dfl_gen[idfl].dp.qhat);
            }
            if ((gauge()&1)!=0)
            {
               n=fdigits(dfl_gen[idfl].dp.su3csw);
               printf("su3csw = %.*f\n",IMAX(n,1),dfl_gen[idfl].dp.su3csw);
            }
            if ((gauge()&2)!=0)
            {
               n=fdigits(dfl_gen[idfl].dp.u1csw);
               printf("u1csw = %.*f\n",IMAX(n,1),dfl_gen[idfl].dp.u1csw);
            }
            if (bc_type()!=3)
            {
               n=fdigits(dfl_gen[idfl].dp.cF[0]);
               printf("cF = %.*f\n",IMAX(n,1),dfl_gen[idfl].dp.cF[0]);
            }
            if (bc_type()==2)
            {
               n=fdigits(dfl_gen[idfl].dp.cF[1]);
               printf("cF' = %.*f\n",IMAX(n,1),dfl_gen[idfl].dp.cF[1]);
            }
            n=fdigits(dfl_gen[idfl].dp.theta[0]);
            printf("theta = %.*f,",IMAX(n,1),dfl_gen[idfl].dp.theta[0]);
            n=fdigits(dfl_gen[idfl].dp.theta[1]);
            printf("%.*f,",IMAX(n,1),dfl_gen[idfl].dp.theta[1]);
            n=fdigits(dfl_gen[idfl].dp.theta[2]);
            printf("%.*f\n",IMAX(n,1),dfl_gen[idfl].dp.theta[2]);
            printf("ninv = %d\n",dfl_gen[idfl].ninv);
            printf("nmr = %d\n",dfl_gen[idfl].nmr);
            printf("ncy = %d\n\n",dfl_gen[idfl].ncy);
         }
      }

      if (ipr)
      {
         printf("Deflation subspace update scheme:\n");
         n=fdigits(dfl_upd.dtau);
         printf("dtau = %.*f\n",IMAX(n,1),dfl_upd.dtau);
         printf("nsm = %d\n\n",dfl_upd.nsm);
      }
      
      fflush(stdout);
   }
}


void write_dfl_parms(FILE *fdat)
{
   int idfl;
   
   write_little_int(1,fdat,8,
      dfl.bs[0],dfl.bs[1],dfl.bs[2],dfl.bs[3],
      dfl.Ns,dfl_pro.nkv,dfl_pro.nmx,dfl_upd.nsm);
   
   write_little_dble(1,fdat,2,dfl_pro.res,dfl_upd.dtau);
   
   for(idfl=0;idfl<DFLMAX;idfl++)
   {
      write_little_int(1,fdat,5,dfl_gen[idfl].status,
         dfl_gen[idfl].ninv,dfl_gen[idfl].nmr,dfl_gen[idfl].ncy,
         dfl_gen[idfl].dp.qhat);
      
      write_little_dble(1,fdat,9,
         dfl_gen[idfl].kappa,dfl_gen[idfl].mu,dfl_gen[idfl].dp.su3csw,
         dfl_gen[idfl].dp.u1csw,dfl_gen[idfl].dp.cF[0],dfl_gen[idfl].dp.cF[1],
         dfl_gen[idfl].dp.theta[0],dfl_gen[idfl].dp.theta[1],
         dfl_gen[idfl].dp.theta[2]);
   }
}


void check_dfl_parms(FILE *fdat)
{
   int idfl;
   
   check_little_int("check_dfl_parms",fdat,8,
      dfl.bs[0],dfl.bs[1],dfl.bs[2],dfl.bs[3],
      dfl.Ns,dfl_pro.nkv,dfl_pro.nmx,dfl_upd.nsm);
   
   check_little_dble("check_dfl_parms",fdat,2,dfl_pro.res,dfl_upd.dtau);
   
   for(idfl=0;idfl<DFLMAX;idfl++)
   {
      check_little_int("check_dfl_parms",fdat,5,dfl_gen[idfl].status,
         dfl_gen[idfl].ninv,dfl_gen[idfl].nmr,dfl_gen[idfl].ncy,
         dfl_gen[idfl].dp.qhat);
      
      check_little_dble("check_dfl_parms",fdat,9,
         dfl_gen[idfl].kappa,dfl_gen[idfl].mu,dfl_gen[idfl].dp.su3csw,
         dfl_gen[idfl].dp.u1csw,dfl_gen[idfl].dp.cF[0],dfl_gen[idfl].dp.cF[1],
         dfl_gen[idfl].dp.theta[0],dfl_gen[idfl].dp.theta[1],
         dfl_gen[idfl].dp.theta[2]);
   }
}


void read_dfl_parms(int idfl)
{
   int my_rank;
   int gg,bc,cs;
   int bs[4],Ns;
   int ninv,nmr,ncy,nkv,nmx,nsm,qhat;
   double kappa,mu,su3csw,u1csw,cF,cF_prime,th1,th2,th3,res,dtau;
   char line[NAME_SIZE];

   check_global_int("read_dfl_parms",1,idfl);

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   gg=gauge();
   bc=bc_type();
   cs=bc_cstar();

   if(idfl<0)
   {
      if (my_rank==0)
      {
         find_section("Deflation subspace");
         read_line("bs","%d %d %d %d",bs,bs+1,bs+2,bs+3);
         read_line("Ns","%d",&Ns);
      }

      MPI_Bcast(bs,4,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&Ns,1,MPI_INT,0,MPI_COMM_WORLD);
      set_dfl_parms(bs,Ns);

      if (my_rank==0)
      {
         find_section("Deflation projection");
         read_line("nkv","%d",&nkv);
         read_line("nmx","%d",&nmx);
         read_line("res","%lf",&res);
      }

      MPI_Bcast(&nkv,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&nmx,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&res,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      set_dfl_pro_parms(nkv,nmx,res);
   }

   if (idfl==-2)
   {
      if (my_rank==0)
      {
         find_section("Deflation update scheme");
         read_line("dtau","%lf",&dtau);
         read_line("nsm","%d",&nsm);
      }

      MPI_Bcast(&dtau,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&nsm,1,MPI_INT,0,MPI_COMM_WORLD);
      set_dfl_upd_parms(dtau,nsm);
   }

   if (idfl>=0)
   {
      qhat=0;
      su3csw=u1csw=0.0;
      cF=cF_prime=0.0;
      th1=th2=th3=0.0;

      if (my_rank==0)
      {
         sprintf(line,"Deflation subspace generation %d",idfl);
         find_section(line);
         read_line("kappa","%lf",&kappa);
         if ((gg&2)!=0)
         {
            read_line("qhat","%d",&qhat);
            read_line("u1csw","%lf",&u1csw);
         }
         if ((gg&1)!=0)
            read_line("su3csw","%lf",&su3csw);
         if (bc!=3) read_line("cF","%lf",&cF);
         if (bc==2) read_line("cF'","%lf",&cF_prime);
         if (cs==0) read_line("theta","%lf %lf %lf",&th1,&th2,&th3);
      
         read_line("mu","%lf",&mu);
      
         read_line("ninv","%d",&ninv);
         read_line("nmr","%d",&nmr);
         read_line("ncy","%d",&ncy);
      }

      MPI_Bcast(&kappa,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&qhat,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&mu,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&su3csw,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&u1csw,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&cF,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&cF_prime,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&th1,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&th2,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&th3,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&ninv,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&nmr,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&ncy,1,MPI_INT,0,MPI_COMM_WORLD);
      set_dfl_gen_parms(idfl,kappa,mu,qhat,su3csw,u1csw,cF,cF_prime,th1,th2,th3,ninv,nmr,ncy);
   }
}
